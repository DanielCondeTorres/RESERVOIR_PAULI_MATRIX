# ‚öõÔ∏è Hamiltonian Implementations (hamiltonian.jl)


This module provides utilities to construct 1D Transverse Field Ising Model (TFIM) Hamiltonians using Pauli strings.  
We distinguish between the standard **homogeneous** model and a **disordered** model (used for localization or spin-glass studies).

---

## 1. Homogeneous Ising Model

**Function:** `build_ising_hamiltonian(n_qubits, J, h)`

Represents a *clean* crystal with translational invariance.  
Every pair of neighboring spins interacts with the same strength, and the magnetic field is uniform across the chain.

### Hamiltonian

$$ H = -J\sum_i Z_i Z_{i+1} \;-\; h \sum_i X_i $$

* **$J$ (Interaction):** Constant scalar.
* **$h$ (Field):** Constant scalar.

**Physics:** Used to study standard quantum phase transitions (Ferromagnetic ‚Üî Paramagnetic).

---

## 2. Disordered Ising Model (Paper Eq. 32)

**Function:** `build_paper_hamiltonian(n_qubits, J_scale, h_const)`

Represents a *disordered* system (e.g., spin glass, impurity model) as defined in Replica Equation (32).  
Interaction strengths vary randomly from bond to bond, breaking translational invariance.

### Hamiltonian

$$ H = -\sum_i J_i\, Z_i Z_{i+1} \;-\; h_{\text{const}} \sum_i X_i $$

* **$J_i$ (Interaction):** Random variable (quenched disorder).  
  Drawn uniformly from:
  $$ J_i \in [-2J_{\text{scale}}, +2J_{\text{scale}}] $$

  Because its sign fluctuates, bonds can be locally ferromagnetic or antiferromagnetic.

 * **$h_{\text{const}}$ (Field):** Constant scalar.
**Physics:** Used to study Many-Body Localization (MBL), thermalization breaking, and disordered quantum systems.

---

## Key Differences

| Feature | `build_ising_hamiltonian` | `build_paper_hamiltonian` |
|--------|----------------------------|----------------------------|
| **System Type** | Clean / Homogeneous | Disordered / Random |
| **Coupling (ZZ)** | Fixed scalar \(J\) | Random array \(J_i\) |
| **Coupling Range** | Deterministic | \([-2J_{\text{scale}}, +2J_{\text{scale}}]\) |
| **Reproducibility** | Always identical | Requires `Random.seed!` to reproduce |

---



# ‚öõÔ∏è  Pauli Operators and Bitmask Algebra (pauli.jl)


This module implements data structures and exact algebra for **multi-qubit Pauli operators** using bitmasks. Each Pauli string is represented following the standard binary symplectic (GF(2)) representation of the Pauli group.

---

## üß© `struct PauliString`

A Pauli operator on *n* qubits can be expressed as:


$$ P = i^k \bigotimes_{j=1}^n P_j,\quad P_j \in {I, X, Y, Z}. $$

Each operator is encoded using two integer bitmasks:

* `x_mask`: indicates which qubits carry an **X** component
* `z_mask`: indicates which qubits carry a **Z** component

The combination per qubit is:

| (x, z) | Operator |
| ------ | -------- |
| (0, 0) | I        |
| (1, 0) | X        |
| (0, 1) | Z        |
| (1, 1) | Y        |

Thus each Pauli string corresponds to:


$$ P = X^{x} Z^{z}. $$

---

## ÔøΩÔøΩ `show(io, p::PauliString)`

This function only provides a human-readable visualization of the bitmasks:

```
P(binary_x_mask, binary_z_mask)
```

It **does not change** the operator or compute anything algebraic.

---

## ‚ú® `multiply_paulis(p1, p2)`

Computes the **exact product** of two Pauli strings:

$$ P_1 P_2 = \phi(P_1, P_2), P_3, $$

where:

* $P_3$ is the resulting Pauli operator,
* $\phi\in{1,-1,i,-i}$ is the phase generated by Pauli non-commutativity.

### üîπ New masks

The resulting operator uses XOR on each mask:

$$ X^{x_1} Z^{z_1} \cdot X^{x_2} Z^{z_2}
= i^{\omega}, X^{x_1 \oplus x_2} Z^{z_1 \oplus z_2}. $$

### üîπ Phase computation

For each qubit where both operators act non-trivially, the function applies the phase relations:


$$ XZ = -iY,\quad ZX = iY, $$

$$ ZY = -iX,\quad YZ = iX, $$

$$ YX = -iZ,\quad XY = iZ. $$

Each such interaction adds a factor of ( \pm i ) to the total phase.

### ‚úîÔ∏è Return value

The function returns:

$$  (\text{phase},; \text{PauliString}(x_1 \oplus x_2,; z_1 \oplus z_2)). $$

---

## üßÆ `commutator(p1, p2)`

Computes the **commutator**:


$$ [A, B] = AB - BA. $$

Pauli operators either **commute** or **anticommute**, determined by the binary symplectic form:

$$  \langle A , B \rangle = (x_A \cdot z_B) + (z_A \cdot x_B) \pmod{2}. $$

### üîπ Case 1 ‚Äî They commute

If:

$$ \langle A , B \rangle = 0, $$

then:


$$ [A, B] = 0. $$

The function returns:

```
(0im, PauliString(0,0))
```

### üîπ Case 2 ‚Äî They anticommute

If:


$$ \langle A , B \rangle = 1, $$

then:

$$ [A, B] = AB - BA = AB - (-AB) = 2AB. $$

The function:

1. computes (AB) using `multiply_paulis`,
2. returns:

$$ (2 \cdot \text{phase}_{AB},; AB). $$

---

# ‚úÖ Summary

| Function          | Mathematical Meaning                                |
| ----------------- | --------------------------------------------------- |
| `PauliString`     | GF(2) representation of Pauli strings (X^x Z^z)     |
| `multiply_paulis` | Exact product in the Pauli group with correct phase |
| `commutator`      | Computes ([A,B]) via the symplectic form            |

---


